---
title: Clone 3rd party dependencies for AI Coding Agents
date: "2026-01-25"
template: "post"
draft: false
slug: "clone-3rd-party-depenendcies-for-ai-coding-agents"
description: |
  A quick tip on how AI coding agents excel when all dependencies are cloned locally. We'll examine a
  practical explanation of implementing a feature in the Ruby on Rails ClickHouse adapter gem.
tags:
  - "ai"
  - "agents"
  - "clickhouse"
  - "active-record"
---

# {frontmatter.title}

_Published on {frontmatter.date}_

I've recently been doing some work on the [clickhouse-activerecord](https://github.com/PNixx/clickhouse-activerecord) gem
and I wanted to share a tip I came across for helping coding agents .

##

I came across this tip while on [x](x.com). It came from [Michael Arnaldi](), who is the creator of [Effect](), a Typescript library. Effect is a very different way of writing Typescript and newcomers were messaging him asking him about
more documentation or the best way to solve some problem. His answer to these questions was to clone Effect into
their project and let the agent read Effect's source code. This is a particular nuance of the Typescript ecosystem where
not all libraries ship their full source code; sometimes the source is shipped in a minified manner and only the
public API is accessible through the code in `node_modules/`. While we don't have that issue in [Ruby on Rails](),
when working on a gem which is an adapter to `ActiveRecord`, there isn't a need to have the `ActiveRecord` code
in the gem self.

That's the tip! If you find yourself working on a project interfacing with 3rd party dependency and the coding
agent is struggling to help, clone that dependency into your project. In all my projects I have a `tmp/` directory with
everything inside it added it `.gitignore` and that is where I'll clone these dependencies into. You'll want to add
explicit instructions prompt to look in `tmp/<dependency>` because by default the coding agent will ignore it. I hope
this helps on the next project you work on and if you're interested in a real world application of this approach, I've
written up how I used it to add a feature to the `clickhouse-activerecord` gem.

## Practical Example - clickhouse-activerecord

At work, we have a handful of monkey patches to the `clickhouse-activerecord`
gem and we're currently stuck on an older version of the gem due to incompatible changes. I made it a goal for
myself to get us onto the latest version of the gem and remove as many of the patches as possible. Some of these
patches are candidates to be upstreamed to the gem and
others were added due to issues we ran into. The first one I aimed to tackle was a patch in our testing suite
to use the [database-cleaner](https://github.com/DatabaseCleaner/database_cleaner) to truncate the ClickHouse tables.
Using `database-cleaner` works, but we're currently maintaining a hardcoded list of tables in `test_helper.rb` to skip
specific tables that cannot be truncated.

```ruby
DatabaseCleaner.strategy = [:truncation, except: %w[widgets, ...]]
```

ClickHouse has a set of table enginges that cannot be truncated and the gem was not taking that into account. Those
engines can be seen int he documentation ... and one other type are dictionaries, which we use a lot at work. Now
that we have the background established, lets set out on figuring out how to implement this.

Because we have the whole RIlas repository in our `temp/` folder, we should have no problem looking up
how other database engines handle truncation.

```

```

The entrypoint is the [BaseAdapter]() and it's `truncate_tables` method. My initial approach was to override
`truncate_tables` and add in our special cases. However, as I was reading through the code in `truncate_tables`,
I noticed it was calling out to another method, ``. I asked my coding agent to explore a bit more.

Discovering that Postgres and Sqlite both had spceific overrides defined was a huge a-ha moment. We don't have to do
any method overriding at all! The toools are all built in to provide a custom set of tables to the truncation method.
Here is my implementation

```ruby

```

The full Pull Request for my changes can be found here, [](). With the change, truncation will now work out of the box
on all types of ClickHouse tables.

## Conclusion

Knowing what I know now, it is very easy to prompt a coding agent using this pattern to give me the explicit answer
up front. Let's take a look at that real quick.

```

```

The harder part in programming, in my opinion, is first discovering what I don't know about the problem I'm facing.
Once that discovery has happened, building the solution is straight forward. If I had known about the
`build_truncate_statements` method from the get go, the amount of time this PR took would have been greatly reduced.
However, with this approach of having the cloned dependency in my `tmp/` directory, I've greatly reduced the amount
of time spent on that discovery.
